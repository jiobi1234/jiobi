# 자동 여행 계획 생성 알고리즘 설계서

## 1. 개요

구글 제미나이 LLM을 활용하여 사용자의 선호도와 제약 조건을 기반으로 최적화된 여행 계획을 자동으로 생성하는 시스템입니다.

---

## 2. 입력 데이터 (사용자 요구사항)

### 2.1 필수 입력
- **여행 기간**: `start_date`, `end_date`
- **여행 지역**: `region` (예: 서울, 부산, 제주도)
- **선택적**: `district` (예: 강남구, 해운대구)

### 2.2 선택 입력 (선호도)
- **여행 스타일**: 
  - 문화/역사 탐방
  - 자연/휴양
  - 쇼핑/먹방
  - 액티비티/레저
  - 로맨틱/커플
  - 가족 여행
  - 혼자 여행
- **예산 범위**: `budget_range` (낮음/보통/높음)
- **이동 수단**: `transportation` (도보/대중교통/렌터카)
- **식사 선호도**: 
  - 현지 음식 선호
  - 특정 음식 타입 (한식/양식/일식/중식 등)
  - 식사 횟수 (하루 2회/3회)
- **관심 카테고리**: 
  - 관광지
  - 음식점
  - 쇼핑
  - 숙박
  - 문화시설
- **특정 장소 요청**: `preferred_places` (place_id 리스트)
- **제외 장소**: `excluded_places` (place_id 리스트)
- **일일 활동 시간**: `daily_start_time`, `daily_end_time` (예: 09:00 ~ 22:00)

### 2.3 위시리스트 연동
- 사용자의 위시리스트에 있는 장소를 우선적으로 고려
- 위시리스트 장소가 있으면 자동으로 계획에 포함

### 2.4 "너가 알아서 짜줘" 모드 (Zero-Input / Smart Default)

사용자가 최소한의 정보만 제공하거나 아무것도 제공하지 않을 때, 시스템이 자동으로 추론하여 계획을 생성합니다.

#### 2.4.1 자동 추론 전략

**1. 여행 기간 추론**
```
- 입력 없음 → 기본값: 오늘부터 2박 3일 (3일)
- 또는 사용자 위치 기반:
  - 현재 위치가 서울이면 → 제주도 3일 추천
  - 현재 위치가 지방이면 → 서울 2-3일 추천
  - 계절 고려:
    - 봄(3-5월): 벚꽃 명소, 꽃 축제 지역
    - 여름(6-8월): 해변, 산, 피서지
    - 가을(9-11월): 단풍 명소, 전통 문화지역
    - 겨울(12-2월): 스키장, 온천, 설경 명소
```

**2. 여행 지역 추론**
```
우선순위:
1. 위시리스트 기반
   - 위시리스트에 특정 지역 장소가 많으면 해당 지역 선택
   - 예: 위시리스트에 제주도 장소가 5개 이상 → 제주도

2. 인기 여행지 추천
   - 계절별 인기 지역 데이터베이스 활용
   - 사용자 위치에서 접근성 좋은 지역
   - 최근 다른 사용자들이 많이 선택한 지역

3. 기본 추천 지역
   - 서울 (가장 인기)
   - 제주도 (휴양)
   - 부산 (해변/도시)
   - 경주 (역사/문화)
```

**3. 여행 스타일 추론**
```
- 위시리스트 카테고리 분석:
  - 관광지 비율 높음 → 문화/역사 탐방
  - 음식점 비율 높음 → 쇼핑/먹방
  - 자연 명소 비율 높음 → 자연/휴양
  
- 사용자 행동 패턴 (과거 계획 분석):
  - 이전에 만든 계획의 스타일 추론
  - 자주 방문한 카테고리 기반 추론
  
- 기본값: "문화/역사 탐방" (가장 범용적)
```

**4. 예산 범위 추론**
```
- 기본값: "보통"
- 또는 위시리스트 장소의 평균 가격대 분석
  - 고급 장소 많음 → "높음"
  - 일반 장소 많음 → "보통" 또는 "낮음"
```

**5. 이동 수단 추론**
```
- 지역 기반:
  - 서울/부산 등 도시 → "대중교통"
  - 제주도/경주 등 넓은 지역 → "렌터카"
  - 작은 구역 (강남구 등) → "도보"
  
- 기본값: "대중교통"
```

**6. 일일 활동 시간 추론**
```
- 기본값: 09:00 ~ 22:00
- 여행 스타일 기반:
  - 자연/휴양 → 08:00 ~ 20:00 (일찍 시작)
  - 쇼핑/먹방 → 10:00 ~ 23:00 (늦게 시작)
```

#### 2.4.2 스마트 기본값 매트릭스

```
입력 정보 수준에 따른 자동 설정:

[Level 0: 완전 자동]
- 입력: 없음 또는 "알아서 해줘"
- 추론:
  * 기간: 오늘부터 2박 3일
  * 지역: 계절별 인기 지역 또는 위시리스트 기반
  * 스타일: 위시리스트 분석 또는 "문화/역사 탐방"
  * 예산: "보통"
  * 이동수단: 지역 기반 추론
  * 활동시간: 09:00 ~ 22:00

[Level 1: 지역만 제공]
- 입력: "서울 가고 싶어"
- 추론:
  * 기간: 2박 3일 (기본)
  * 지역: 서울
  * 스타일: 서울 인기 스타일 (문화/역사 또는 쇼핑/먹방)
  * 예산: "보통"
  * 이동수단: "대중교통"
  * 활동시간: 09:00 ~ 22:00

[Level 2: 기간만 제공]
- 입력: "3일 여행"
- 추론:
  * 기간: 오늘부터 3일
  * 지역: 계절별 인기 지역 또는 위시리스트 기반
  * 스타일: 위시리스트 분석 또는 기본값
  * 나머지: Level 0과 동일

[Level 3: 기간 + 지역]
- 입력: "제주도 3일"
- 추론:
  * 기간: 3일
  * 지역: 제주도
  * 스타일: "자연/휴양" (제주도 특성)
  * 이동수단: "렌터카" (제주도 특성)
  * 나머지: 기본값
```

#### 2.4.3 LLM 기반 스마트 추론

**추가 프롬프트 (Zero-Input 모드용):**
```
사용자가 최소한의 정보만 제공했습니다. 
다음 정보를 바탕으로 최적의 여행 계획을 추천해주세요:

[제공된 정보]
- 여행 기간: {inferred_period}
- 여행 지역: {inferred_region}
- 추론된 스타일: {inferred_style}

[추가 컨텍스트]
- 현재 계절: {current_season}
- 사용자 위시리스트 분석: {wishlist_analysis}
- 인기 여행지 트렌드: {trending_destinations}

[요청사항]
위 정보를 바탕으로 이 시기에 {inferred_region}에서 
{inferred_style} 스타일로 즐길 수 있는 최고의 여행 계획을 생성해주세요.
계절적 특색과 지역의 대표적인 매력을 반영해주세요.
```

---

## 3. 알고리즘 프로세스

### 3.1 Phase 0: 입력 검증 및 자동 추론 (Zero-Input 모드)

#### 3.0.1 입력 레벨 판단
```
사용자 입력을 분석하여 입력 레벨 판단:
- Level 0: 입력 없음 또는 "알아서 해줘"
- Level 1: 지역만 제공
- Level 2: 기간만 제공  
- Level 3: 기간 + 지역
- Level 4: 기간 + 지역 + 스타일 (이상)
```

#### 3.0.4 지역 범위 검증 및 멀티 지역 처리

**문제 상황:**
- 사용자가 3일 여행인데 서울, 부산, 제주도를 모두 가고 싶다고 함
- 또는 인천에서 시작해서 강원도까지 가고 싶다고 함
- 멀리 떨어진 지역을 짧은 기간에 모두 방문하려고 함

**검증 로직:**
```
1. 선택된 지역 간 거리 계산
   - 각 지역의 중심 좌표 계산
   - 지역 간 직선 거리 및 실제 이동 시간 계산
   
2. 현실성 검증
   - 여행 일수 vs 필요한 이동 시간 비교
   - 예: 서울-부산: KTX 3시간, 서울-제주: 비행기 1.5시간
   - 3일 여행에 서울+부산+제주는 비현실적
   
3. 임계값 설정
   - 일일 최대 이동 시간: 3-4시간
   - 지역 간 거리 기준:
     * 100km 이하: 같은 날 방문 가능
     * 100-300km: 다음 날 이동 고려
     * 300km 이상: 별도 날짜 할당 필요
```

**처리 전략:**

**전략 1: 현실성 경고 및 옵션 제시**
```
사용자에게 알림:
"선택하신 지역들이 멀리 떨어져 있어 3일 동안 모두 방문하기 어렵습니다.

옵션 1: 하나의 지역으로 집중 (추천)
  - 서울만: 3일 동안 서울 깊이 탐방
  - 부산만: 3일 동안 부산 깊이 탐방
  
옵션 2: 2개 지역 방문
  - 서울 + 경주: 1일 서울, 2일 경주
  - 부산 + 제주: 1일 부산, 2일 제주
  
옵션 3: 멀티 지역 계획 (빠른 여행)
  - 서울 + 부산: 1일 서울, 이동, 2일 부산
  - 이동 시간이 많아 관광 시간은 줄어듭니다

어떤 옵션을 선택하시겠습니까?"
```

**전략 2: 자동으로 현실적인 계획 생성**
```
1. 지역 우선순위 결정
   - 위시리스트 장소가 많은 지역 우선
   - 계절별 인기 지역 우선
   - 접근성 좋은 지역 우선

2. 멀티 지역 계획 생성
   - Day 1: 지역 A (출발지 또는 첫 번째 지역)
   - Day 2: 이동 + 지역 B (이동 시간 포함)
   - Day 3: 지역 B 또는 지역 C
   
3. 이동 시간 고려
   - 장거리 이동은 저녁/밤 시간 활용
   - 또는 다음 날 아침 일찍 이동
   - 이동 수단에 따른 시간 배정
```

**전략 3: 지역 그룹핑**
```
비슷한 거리의 지역끼리 묶기:
- 서울 + 인천 + 경기: 1일 여행 가능
- 부산 + 경주: 1-2일 여행 가능
- 제주도: 독립적으로 2-3일 필요

3일 여행 예시:
- 옵션 A: 서울+인천 (1일) + 부산 (2일)
- 옵션 B: 서울 (2일) + 경주 (1일)
- 옵션 C: 제주도만 (3일)
```

#### 3.0.2 자동 추론 실행
```
입력 레벨에 따라 자동 추론:

1. 여행 기간 추론
   - 입력 없음 → 오늘부터 2박 3일
   - 자연어 파싱 ("다음 주말", "3일", "주말 여행" 등)

2. 여행 지역 추론
   - 위시리스트 기반 분석
   - 계절별 인기 지역 추천
   - 사용자 위치 기반 추천

3. 여행 스타일 추론
   - 위시리스트 카테고리 분석
   - 과거 계획 분석 (있는 경우)
   - 지역 특성 기반 추론

4. 나머지 파라미터 기본값 설정
```

#### 3.0.3 추론 결과 확인 및 사용자 확인 (선택적)
```
자동 추론된 값들을 사용자에게 간단히 확인 요청:
"다음과 같이 계획을 생성할까요?
- 기간: 2024-01-15 ~ 2024-01-17 (3일)
- 지역: 서울
- 스타일: 문화/역사 탐방
- 예산: 보통

[확인] [수정하기]"

- 확인: 바로 계획 생성 진행
- 수정하기: 일부 값만 수정 가능
- 또는 자동 진행 옵션 (사용자가 설정)
```

### 3.1 Phase 1: 데이터 수집 및 전처리

#### 3.1.0 멀티 지역 계획 생성 (지역이 멀리 떨어진 경우)

**시나리오: 사용자가 "서울, 부산, 제주도 3일 여행" 요청**

**Step 1: 지역 간 거리 및 이동 시간 계산**
```
서울 ↔ 부산: 약 330km, KTX 3시간, 자동차 4-5시간
서울 ↔ 제주: 약 450km, 비행기 1.5시간
부산 ↔ 제주: 약 200km, 비행기 1시간

3일 동안 모두 방문: 비현실적 (이동만 1.5일 소요)
```

**Step 2: 현실적인 옵션 생성**

**옵션 A: 2개 지역 집중 (추천)**
```
Day 1: 서울 (서울 관광)
Day 2: 이동 (서울 → 부산, KTX 3시간) + 부산 도착 후 관광
Day 3: 부산 (부산 관광)

또는

Day 1: 서울 (서울 관광)
Day 2: 이동 (서울 → 제주, 비행기 1.5시간) + 제주 도착 후 관광
Day 3: 제주 (제주 관광)
```

**옵션 B: 하나의 지역 집중 (더 여유롭게)**
```
Day 1-3: 서울만 (서울 깊이 탐방)
또는
Day 1-3: 부산만 (부산 깊이 탐방)
또는
Day 1-3: 제주도만 (제주도 깊이 탐방)
```

**Step 3: LLM에 멀티 지역 정보 전달**
```
프롬프트에 추가:
"[주의사항]
- 여러 지역을 방문하는 계획입니다
- Day 2에 서울 → 부산 이동 (KTX 3시간) 포함
- 이동 시간을 고려하여 현실적인 일정을 구성해주세요
- 이동일에는 도착 후 간단한 활동만 배치"
```

**Step 4: 멀티 지역 계획 생성**
```json
{
  "plan": {
    "title": "서울 + 부산 3일 여행",
    "description": "서울 1일, 부산 2일 여행",
    "days": [
      {
        "date": "2024-01-15",
        "region": "서울",
        "items": [
          {
            "place_id": "seoul_1",
            "start_time": "09:00",
            "end_time": "12:00",
            "category": "관광지",
            "notes": "서울 명소 방문"
          },
          {
            "place_id": "seoul_2",
            "start_time": "13:00",
            "end_time": "18:00",
            "category": "관광지",
            "notes": "서울 관광 계속"
          }
        ]
      },
      {
        "date": "2024-01-16",
        "region": "서울 → 부산",
        "is_travel_day": true,
        "items": [
          {
            "place_id": "travel",
            "start_time": "08:00",
            "end_time": "11:00",
            "category": "이동",
            "notes": "서울 → 부산 KTX (3시간)"
          },
          {
            "place_id": "busan_1",
            "start_time": "14:00",
            "end_time": "17:00",
            "category": "관광지",
            "notes": "부산 도착 후 해운대 해수욕장"
          }
        ]
      },
      {
        "date": "2024-01-17",
        "region": "부산",
        "items": [
          {
            "place_id": "busan_2",
            "start_time": "09:00",
            "end_time": "12:00",
            "category": "관광지",
            "notes": "부산 관광"
          }
        ]
      }
    ]
  }
}
```

#### 3.1.1 장소 데이터 수집
```
1. 지역 기반 장소 검색
   - TourAPI/KakaoAPI를 통해 region/district 기반 장소 조회
   - 카테고리별로 분류 (관광지, 음식점, 쇼핑, 숙박 등)
   
2. 위시리스트 장소 조회
   - 사용자 위시리스트에서 장소 정보 가져오기
   - 위시리스트 장소는 우선순위 높게 설정
   
3. 장소 상세 정보 수집
   - 각 장소의 운영시간, 휴무일, 위치 좌표, 카테고리 등
   - 거리 계산을 위한 좌표 정보
```

#### 3.1.3 필수 코스 선정 기준 (Zero-Input 모드)

사용자가 아무런 정보도 제공하지 않을 때, AI가 추천하는 '필수 코스'를 선정하는 기준입니다.

**1. 지역별 대표 명소 우선순위**

```
우선순위 점수 계산:
총점 = 인기도(40%) + 접근성(20%) + 계절성(20%) + 카테고리 균형(20%)

[인기도 지표 (40점 만점)]
- TourAPI/KakaoAPI 조회수/리뷰 수
- 최근 방문자 수 (있는 경우)
- 소셜 미디어 언급 빈도
- 다른 사용자들의 선택 빈도
- 국가/지역 지정 문화재/명소 여부

[접근성 지표 (20점 만점)]
- 대중교통 접근성 (지하철/버스 거리)
- 주차 가능 여부
- 무료 입장 여부 (예산 낮음 고려)
- 운영시간 (09:00-18:00 등 일반적 시간)

[계절성 지표 (20점 만점)]
- 현재 계절에 적합한 장소
  * 봄: 벚꽃, 꽃 축제, 산책로
  * 여름: 해변, 피서지, 실내 관광지
  * 가을: 단풍, 전통 문화지역
  * 겨울: 온천, 스키장, 실내 명소
- 계절별 특별 이벤트/축제

[카테고리 균형 (20점 만점)]
- 관광지, 음식점, 쇼핑, 문화시설 등 균형
- 지역의 대표적인 특색 반영
  * 서울: 궁궐, 전통시장, 현대적 명소
  * 제주도: 자연 명소, 해변, 카페거리
  * 부산: 해변, 시장, 문화마을
```

**2. 지역별 필수 코스 예시**

```
[서울 - 3일 여행 필수 코스]
Day 1:
- 경복궁 (인기도: 10/10, 접근성: 10/10, 계절성: 8/10)
- 북촌한옥마을 (인기도: 9/10, 접근성: 9/10, 계절성: 8/10)
- 인사동 (인기도: 8/10, 접근성: 10/10, 계절성: 7/10)
- 광장시장 (음식점, 인기도: 9/10)

Day 2:
- 남산타워 (인기도: 9/10, 접근성: 8/10, 계절성: 7/10)
- 명동 (쇼핑, 인기도: 8/10)
- 동대문디자인플라자 (인기도: 8/10, 접근성: 9/10)

Day 3:
- 한강공원 (자연, 인기도: 8/10, 계절성: 9/10)
- 이태원/한남동 (카페거리, 인기도: 7/10)

[제주도 - 3일 여행 필수 코스]
Day 1:
- 성산일출봉 (자연, 인기도: 10/10, 계절성: 9/10)
- 섭지코지 (자연, 인기도: 9/10, 계절성: 8/10)
- 제주 현지 음식점

Day 2:
- 한라산 (자연, 인기도: 10/10, 계절성: 8/10)
- 오설록 티뮤지엄 (문화, 인기도: 8/10)

Day 3:
- 협재해수욕장 (자연, 인기도: 9/10, 계절성: 10/10)
- 카멜리아힐 (자연, 인기도: 8/10, 계절성: 9/10)

[부산 - 3일 여행 필수 코스]
Day 1:
- 해운대 해수욕장 (자연, 인기도: 10/10, 계절성: 9/10)
- 부산 현지 해산물 식당

Day 2:
- 감천문화마을 (문화, 인기도: 9/10, 접근성: 8/10)
- 자갈치시장 (음식점, 인기도: 9/10)

Day 3:
- 태종대 (자연, 인기도: 8/10, 계절성: 8/10)
- 부산타워 (인기도: 7/10)
```

**3. LLM 프롬프트에 필수 코스 정보 전달**

```
프롬프트에 추가:
"[지역별 필수 코스 가이드]
다음은 {region}의 대표적인 필수 코스입니다. 
이 장소들을 우선적으로 고려하여 계획을 생성해주세요:

필수 코스 목록:
1. {place_name} (place_id: {id})
   - 인기도: 높음
   - 카테고리: {category}
   - 특징: {features}
   
2. {place_name} (place_id: {id})
   ...

[선정 기준]
- 인기도가 높은 대표 명소 우선 포함
- 지역의 특색을 대표하는 장소 포함
- 계절에 맞는 장소 우선
- 접근성이 좋은 장소 우선
- 카테고리별 균형 유지 (관광지, 음식점, 쇼핑 등)

[주의사항]
- 필수 코스를 모두 포함할 필요는 없지만, 최소 1-2개는 포함 권장
- 사용자가 특별한 선호도가 없으면 필수 코스 중심으로 계획 생성
- 필수 코스와 주변 장소를 묶어서 효율적인 경로 구성"
```

**4. 필수 코스 데이터베이스 구조**

```json
{
  "region": "서울",
  "must_visit_places": [
    {
      "place_id": "12345",
      "name": "경복궁",
      "category": "관광지",
      "priority_score": 95,
      "seasonal_score": {
        "spring": 8,
        "summer": 7,
        "autumn": 9,
        "winter": 6
      },
      "accessibility": 10,
      "popularity": 10,
      "tags": ["역사", "문화재", "무료입장일"],
      "nearby_places": ["북촌한옥마을", "인사동"]
    }
  ],
  "recommended_combinations": [
    {
      "places": ["경복궁", "북촌한옥마을", "인사동"],
      "reason": "가까운 거리, 역사/전통 테마"
    }
  ]
}
```

**5. 필수 코스 선정 알고리즘**

```python
def select_must_visit_places(region, days, season, budget):
    """
    필수 코스 선정 알고리즘
    
    Args:
        region: 여행 지역
        days: 여행 일수
        season: 현재 계절
        budget: 예산 범위
    
    Returns:
        selected_places: 선정된 필수 코스 리스트
    """
    # 1. 지역별 필수 코스 데이터베이스 조회
    must_visit_db = get_must_visit_places(region)
    
    # 2. 점수 계산
    for place in must_visit_db:
        score = (
            place.popularity * 0.4 +           # 인기도 40%
            place.accessibility * 0.2 +        # 접근성 20%
            place.seasonal_score[season] * 0.2 + # 계절성 20%
            category_balance_score(place) * 0.2  # 카테고리 균형 20%
        )
        place.total_score = score
    
    # 3. 예산 필터링
    if budget == "낮음":
        must_visit_db = filter_free_or_cheap(must_visit_db)
    
    # 4. 상위 N개 선정 (여행 일수에 따라)
    places_per_day = 3
    total_places = days * places_per_day
    selected = sorted(must_visit_db, key=lambda x: x.total_score, reverse=True)[:total_places]
    
    # 5. 카테고리 균형 확인
    selected = balance_categories(selected)
    
    return selected
```

**6. 필수 코스 업데이트 전략**

```
- 정기적으로 업데이트 (월 1회 또는 계절마다)
- 사용자 피드백 반영
  * 사용자가 자주 제외하는 장소는 우선순위 낮춤
  * 사용자가 자주 추가하는 장소는 우선순위 높임
- 트렌드 반영
  * 최근 인기 급상승 장소
  * SNS/블로그에서 자주 언급되는 장소
- 계절별 조정
  * 계절에 맞지 않는 장소는 해당 계절에 제외
```

#### 3.1.2 데이터 구조화
```
각 장소를 다음 정보로 구조화:
{
  place_id: string
  title: string
  category: string (관광지/음식점/쇼핑/숙박)
  latitude: float
  longitude: float
  address: string
  operating_hours: string (운영시간)
  rest_day: string (휴무일)
  estimated_duration: int (예상 체류 시간, 분 단위)
  priority: int (위시리스트면 높은 우선순위)
}
```

---

### 3.2 Phase 2: LLM 기반 계획 생성

#### 3.2.1 프롬프트 구성

**시스템 프롬프트:**
```
당신은 전문 여행 계획 AI 어시스턴트입니다. 
사용자의 선호도와 제약 조건을 고려하여 최적화된 일일 여행 계획을 생성합니다.

다음 원칙을 따라야 합니다:
1. 이동 시간을 고려한 현실적인 일정 구성
2. 카테고리별 균형 (관광지, 식사, 휴식)
3. 지리적 근접성 고려 (가까운 장소끼리 묶기)
4. 운영시간 및 휴무일 확인
5. 사용자 선호도 반영
```

**사용자 프롬프트 템플릿:**
```
여행 계획을 생성해주세요.

[기본 정보]
- 여행 기간: {start_date} ~ {end_date} ({day_count}일)
- 여행 지역: {region} {district}
- 여행 스타일: {travel_style}
- 예산: {budget_range}
- 이동 수단: {transportation}
- 일일 활동 시간: {daily_start_time} ~ {daily_end_time}

[선호도]
- 관심 카테고리: {categories}
- 식사 선호도: {meal_preferences}
- 특정 장소 요청: {preferred_places}
- 제외 장소: {excluded_places}

[사용 가능한 장소 목록]
{formatted_places_list}

위 정보를 바탕으로 각 날짜별로 다음 형식의 계획을 생성해주세요:

날짜: YYYY-MM-DD
- [시간] [장소명] (place_id: xxx) - [카테고리] - 예상 소요시간: XX분
  이동시간: XX분 (이전 장소에서)
  메모: [관련 정보]

요구사항:
1. 각 날짜별로 3-5개의 주요 장소를 배치
2. 이동 시간을 고려하여 지리적으로 가까운 순서로 배치
3. 식사 시간을 고려하여 음식점을 적절히 배치
4. 관광지와 휴식 시간의 균형 유지
5. 운영시간과 휴무일을 확인하여 방문 가능한 장소만 선택
6. JSON 형식으로 응답 (아래 형식 참고)
```

**응답 형식 (JSON):**
```json
{
  "plan": {
    "title": "생성된 계획 제목",
    "description": "계획 설명",
    "days": [
      {
        "date": "2024-01-15",
        "items": [
          {
            "place_id": "123456",
            "start_time": "09:00",
            "end_time": "11:00",
            "estimated_duration": 120,
            "travel_time_from_previous": 0,
            "category": "관광지",
            "notes": "조용한 시간대 방문 권장"
          },
          {
            "place_id": "789012",
            "start_time": "12:00",
            "end_time": "13:30",
            "estimated_duration": 90,
            "travel_time_from_previous": 30,
            "category": "음식점",
            "notes": "현지 특색 음식"
          }
        ]
      }
    ]
  },
  "reasoning": "계획 생성 근거 설명"
}
```

#### 3.2.2 LLM 호출 전략

**1단계: 전체 계획 초안 생성**
- 전체 여행 기간을 한 번에 고려하여 일관된 계획 생성
- Gemini API 호출 (모델: gemini-pro 또는 gemini-1.5-pro)

**2단계: 검증 및 최적화**
- LLM이 생성한 계획의 유효성 검증
  - place_id가 실제 존재하는지 확인
  - 운영시간 내 방문 가능한지 확인
  - 이동 시간이 현실적인지 확인
- 문제가 있으면 재생성 또는 수정

**3단계: 세부 시간 조정**
- 지리적 거리 기반 이동 시간 재계산
- 운영시간에 맞춰 시간 조정
- 사용 가능 시간 내에 모든 일정이 들어가는지 확인

---

### 3.3 Phase 3: 지리적 최적화

#### 3.3.1 거리 계산
```
각 장소 간 거리 계산 (Haversine 공식 또는 실제 도로 거리 API)
- 위도/경도 기반 직선 거리
- 이동 수단에 따른 예상 이동 시간 계산
  - 도보: 5km/h
  - 대중교통: 실제 경로 API 사용 (선택적)
  - 렌터카: 도로 거리 기반
```

#### 3.3.2 경로 최적화
```
같은 날짜 내 장소 순서 최적화:
1. 시작 지점 설정 (숙박지 또는 첫 방문지)
2. TSP (Traveling Salesman Problem) 근사 알고리즘 적용
   - 가까운 장소끼리 묶기
   - 이동 시간 최소화
3. 시간 제약 조건 확인
   - 각 장소의 운영시간
   - 예상 체류 시간
   - 이동 시간
```

---

### 3.4 Phase 4: 시간 스케줄링

#### 4.1 시간 배분 알고리즘
```
각 날짜별로:
1. 사용 가능 시간 계산 (daily_start_time ~ daily_end_time)
2. 장소별 예상 소요 시간 할당
   - 관광지: 1-3시간
   - 음식점: 1-2시간
   - 쇼핑: 1-2시간
   - 휴식: 30분-1시간
3. 이동 시간 고려하여 시간 슬롯 배정
4. 여유 시간 확보 (각 활동 사이 15-30분)
```

#### 4.2 시간 조정 규칙
```
- 운영시간 확인: 장소의 운영시간 내에만 배정
- 휴무일 확인: 해당 날짜가 휴무일이면 제외
- 식사 시간 고려: 
  - 아침: 08:00-10:00
  - 점심: 12:00-14:00
  - 저녁: 18:00-20:00
- 관광지 운영시간: 
  - 대부분 09:00-18:00
  - 야경 명소는 저녁 시간대 배정
```

---

### 3.5 Phase 5: 검증 및 후처리

#### 5.1 검증 항목
```
1. 모든 place_id가 유효한지 확인
2. 날짜 형식이 올바른지 확인 (YYYY-MM-DD)
3. 시간 형식이 올바른지 확인 (HH:MM)
4. start_time < end_time 확인
5. 일정이 겹치지 않는지 확인
6. 이동 시간이 현실적인지 확인
7. 운영시간 내 방문 가능한지 확인
```

#### 5.2 자동 수정
```
검증 실패 시:
1. 경고 로그 기록
2. 자동 수정 시도:
   - 시간 조정
   - 장소 교체 (유사한 장소로)
   - 일정 재배치
3. 수정 불가능하면 사용자에게 알림
```

---

## 4. API 엔드포인트 설계

### 4.1 자동 계획 생성 요청

#### 4.1.1 기본 요청 (모든 필드 선택적)
```
POST /api/hk/plan/auto-generate

Request Body (모든 필드 선택적):
{
  "start_date": "2024-01-15",           // 선택적, 없으면 자동 추론
  "end_date": "2024-01-17",             // 선택적, 없으면 자동 추론
  "region": "서울",                     // 선택적, 없으면 자동 추론
  "district": "강남구",                  // 선택적
  "travel_style": "문화/역사 탐방",     // 선택적, 없으면 자동 추론
  "budget_range": "보통",               // 선택적, 기본값: "보통"
  "transportation": "대중교통",          // 선택적, 지역 기반 추론
  "daily_start_time": "09:00",         // 선택적, 기본값: "09:00"
  "daily_end_time": "22:00",           // 선택적, 기본값: "22:00"
  "categories": ["관광지", "음식점"],   // 선택적
  "meal_preferences": {                 // 선택적
    "prefer_local": true,
    "meals_per_day": 3
  },
  "preferred_places": ["place_id_1"],   // 선택적
  "excluded_places": ["place_id_3"],   // 선택적
  "use_wishlist": true,                 // 선택적, 기본값: true
  "auto_mode": true                     // true면 최소 입력으로도 진행
}

최소 요청 예시 (Zero-Input):
POST /api/hk/plan/auto-generate
{
  "auto_mode": true
}

또는 자연어 요청:
POST /api/hk/plan/auto-generate
{
  "natural_language": "서울 3일 여행"
}
```

#### 4.1.2 자연어 입력 처리
```
자연어 입력을 파싱하여 구조화된 데이터로 변환:

예시:
- "서울 3일" → { region: "서울", duration: 3 }
- "다음 주말 제주도" → { region: "제주도", start_date: 다음주 토요일 }
- "2박 3일 부산 여행" → { region: "부산", duration: 3 }
- "알아서 해줘" → { auto_mode: true }

자연어 파싱은 LLM 또는 규칙 기반 파서 사용
```

Response:
{
  "plan_id": "generated_plan_id",
  "title": "생성된 계획 제목",
  "description": "계획 설명",
  "start_date": "2024-01-15",
  "end_date": "2024-01-17",
  "items": [
    {
      "place_id": "123456",
      "date": "2024-01-15",
      "start_time": "09:00",
      "end_time": "11:00",
      "notes": "조용한 시간대 방문 권장"
    }
  ],
  "generation_metadata": {
    "model_used": "gemini-1.5-pro",
    "generated_at": "2024-01-10T10:00:00Z",
    "reasoning": "계획 생성 근거"
  }
}
```

### 4.2 빠른 계획 생성 (One-Click)
```
POST /api/hk/plan/quick-generate

최소 입력으로 즉시 계획 생성:
- 사용자 위치 또는 위시리스트 기반
- 계절별 인기 지역 자동 선택
- 가장 빠른 응답 (30초 이내 목표)

Request Body:
{
  "hint": "서울"  // 선택적, 힌트만 제공해도 됨
}

Response:
{
  // 기본 계획 생성 응답과 동일
  "auto_selected": {
    "region": "서울",
    "duration": 3,
    "style": "문화/역사 탐방",
    "reason": "계절별 인기 지역 및 위시리스트 분석 결과"
  }
}
```

### 4.3 계획 재생성 (부분 수정)
```
POST /api/hk/plan/{plan_id}/regenerate-day

Request Body:
{
  "date": "2024-01-15",
  "preferences": {
    // 특정 날짜에 대한 추가 선호도
  }
}

Response:
{
  // 해당 날짜의 새로운 일정
}
```

---

## 5. 에러 처리 및 예외 상황

### 5.1 LLM 응답 실패
```
- 재시도 로직 (최대 3회)
- 대체 모델 사용 (gemini-pro → gemini-1.5-pro)
- 기본 규칙 기반 계획 생성 (폴백)
```

### 5.2 데이터 부족
```
- 장소 데이터가 부족한 경우:
  - 더 넓은 지역으로 검색 확대
  - 카테고리 확대
  - 사용자에게 알림 및 수동 선택 옵션 제공
```

### 5.3 시간 제약 위반
```
- 일정이 너무 빡빡한 경우:
  - 장소 수 줄이기
  - 체류 시간 조정
  - 사용자에게 알림
```

### 5.4 Zero-Input 모드 예외 상황
```
- 위시리스트가 비어있고 지역 추론 실패:
  → 가장 인기 있는 지역(서울) 기본값 사용
  → 사용자에게 "서울로 계획을 생성했습니다" 알림

- 계절 정보 부족:
  → 현재 날짜 기반 계절 추론
  → 계절별 특색 반영 실패 시 일반적인 계획 생성

- 자연어 파싱 실패:
  → 키워드만 추출하여 부분 추론
  → 실패 시 사용자에게 간단한 질문으로 대체
  → 예: "어느 지역으로 가시나요?" (드롭다운 제공)

- 모든 추론 실패:
  → 기본값으로 계획 생성 (서울, 2박 3일, 문화/역사 탐방)
  → 생성된 계획에 "기본 추천 계획" 태그 표시
  → 사용자가 쉽게 수정할 수 있도록 안내
```

### 5.5 멀티 지역 계획 예외 상황

#### 5.5.1 비현실적인 지역 조합
```
- 문제: 3일 여행에 서울+부산+제주도 모두 방문 요청
- 처리:
  1. 지역 간 거리 및 이동 시간 계산
  2. 현실성 검증 (이동 시간 > 여행 일수의 50%면 경고)
  3. 사용자에게 옵션 제시:
     * 옵션 1: 하나의 지역으로 집중
     * 옵션 2: 2개 지역 방문 (이동 시간 고려)
     * 옵션 3: 멀티 지역 계획 (빠른 여행, 관광 시간 제한적)
  4. 사용자 선택 대기 또는 자동으로 현실적인 옵션 선택
```

#### 5.5.2 이동 수단 제약
```
- 문제: 렌터카 없이 멀리 떨어진 지역 방문
- 처리:
  * 대중교통만 가능한 경우: KTX/비행기 시간 고려
  * 렌터카 필요한 경우: 렌터카 대여 정보 제공 또는 대중교통으로 변경
  * 도보만 가능: 100km 이내 지역만 선택 가능
```

#### 5.5.3 이동일 일정 최적화
```
- 문제: 이동일에 너무 많은 일정 배치
- 처리:
  * 이동일에는 도착 후 2-3개 장소만 배치
  * 이동 시간을 충분히 확보 (여유 시간 포함)
  * 이동 후 첫 장소는 가벼운 활동 (카페, 산책 등)
  * 무거운 관광은 다음 날로 배치
```

---

## 6. 성능 최적화

### 6.1 캐싱 전략
```
- 지역별 장소 목록 캐싱 (1일)
- LLM 응답 캐싱 (유사한 요청에 대해)
- 거리 계산 결과 캐싱
```

### 6.2 비동기 처리
```
- 장기간 여행 계획 생성 시:
  - 백그라운드 작업으로 처리
  - WebSocket 또는 Polling으로 진행 상황 전달
  - 완료 시 알림
```

### 6.3 배치 처리
```
- 여러 장소 정보를 한 번에 조회
- 병렬 API 호출
```

---

## 7. 사용자 경험 개선

### 7.1 Zero-Input 모드 UX

#### 7.1.1 원클릭 계획 생성
```
UI에 "지금 바로 여행 계획 만들기" 버튼 제공:
- 클릭 시 즉시 계획 생성 시작
- 진행 상황 표시 (로딩 애니메이션)
- 30초 이내 초안 제공
```

#### 7.1.2 추론 결과 투명성
```
생성된 계획에 "왜 이렇게 만들었나요?" 섹션:
- "계절(봄)을 고려하여 벚꽃 명소를 포함했습니다"
- "위시리스트에 서울 장소가 많아 서울을 선택했습니다"
- "3일 기간에 맞춰 하루 3-4곳씩 배치했습니다"
```

#### 7.1.3 간편 수정 옵션
```
생성 후 간단한 수정 버튼:
- "지역 바꾸기" → 드롭다운으로 다른 지역 선택
- "기간 바꾸기" → 날짜 선택
- "스타일 바꾸기" → 스타일 선택
- "다시 만들기" → 새로운 계획 생성
```

### 7.2 단계별 생성
```
1. 빠른 초안 생성 (30초 이내)
2. 사용자 확인 후 세부 최적화
3. 최종 계획 생성
```

### 7.3 사용자 피드백 반영
```
- 생성된 계획에 대한 사용자 수정
- 수정 내용을 학습 데이터로 활용 (선택적)
- 다음 계획 생성 시 선호도 반영
```

### 7.3 대안 제시
```
- 각 장소에 대한 대안 장소 제시
- 시간대별 대안 일정 제시
```

---

## 8. 구현 우선순위

### Phase 1 (MVP)
1. 기본 자동 계획 생성 (LLM 기반)
2. **Zero-Input 모드 (최소 입력으로 계획 생성)**
3. 필수 입력만 받아서 계획 생성
4. 기본 검증 로직
5. 위시리스트 기반 자동 추론

### Phase 2
1. 지리적 최적화
2. 시간 스케줄링 고도화
3. 자연어 입력 파싱
4. 계절별/트렌드 기반 추천
5. 사용자 행동 패턴 분석

### Phase 3
1. 사용자 선호도 학습
2. 실시간 최적화
3. 대안 제시 기능

---

## 9. 보안 및 비용 고려사항

### 9.1 API 키 관리
```
- 구글 제미나이 API 키는 환경 변수로 관리
- API 호출 제한 및 모니터링
```

### 9.2 비용 최적화
```
- 프롬프트 최적화 (토큰 수 최소화)
- 캐싱 활용
- 배치 처리
- 사용량 모니터링
```

---

## 10. 테스트 시나리오

### 10.1 기본 시나리오
```
- 입력: 서울 3일 여행, 문화 탐방
- 예상: 관광지 중심, 하루 3-4곳, 식사 포함
```

### 10.2 복잡한 시나리오
```
- 입력: 제주도 5일, 자연/휴양, 렌터카
- 예상: 넓은 지역, 이동 시간 고려, 자연 명소 중심
```

### 10.3 제약 조건 시나리오
```
- 입력: 특정 장소 필수 포함, 제외 장소 있음
- 예상: 필수 장소 포함, 제외 장소 제외, 나머지 최적화
```

### 10.4 Zero-Input 시나리오
```
- 입력: 없음 또는 "알아서 해줘"
- 예상: 
  * 계절별 인기 지역 자동 선택
  * 위시리스트 기반 스타일 추론
  * 2박 3일 기본 기간
  * 기본값으로 완전한 계획 생성

- 입력: "서울"
- 예상:
  * 서울 지역으로 2박 3일 계획
  * 서울 인기 스타일 자동 선택
  * 대중교통 기반 일정

- 입력: "3일 여행"
- 예상:
  * 계절별 인기 지역 자동 선택
  * 3일 기간으로 계획 생성
  * 나머지 자동 추론
```

### 10.5 멀티 지역 시나리오
```
- 입력: "서울, 부산, 제주도 3일 여행"
- 예상:
  * 지역 간 거리 계산 (서울-부산: 330km, 서울-제주: 450km)
  * 현실성 검증: 3개 지역 모두 방문 비현실적
  * 옵션 제시:
    - 서울+부산 2개 지역 (1일 서울, 이동, 2일 부산)
    - 서울+제주 2개 지역 (1일 서울, 이동, 2일 제주)
    - 하나의 지역 집중 (서울만, 부산만, 제주만)
  * 사용자 선택 또는 자동으로 현실적인 옵션 선택

- 입력: "인천에서 강원도까지 3일"
- 예상:
  * 인천-강원도 거리 계산 (약 200-300km)
  * 이동 시간 고려 (대중교통 3-4시간)
  * 계획:
    - Day 1: 인천 관광
    - Day 2: 이동 (인천 → 강원도) + 강원도 도착 후
    - Day 3: 강원도 관광

- 입력: "서울, 인천, 경기 3일"
- 예상:
  * 지역 간 거리 계산 (모두 100km 이내)
  * 같은 날 방문 가능한 거리
  * 계획:
    - Day 1: 서울 관광
    - Day 2: 인천 관광 (서울에서 이동 1시간)
    - Day 3: 경기 관광 (인천에서 이동 1시간)
```

---

## 11. 향후 개선 방향

1. **머신러닝 통합**: 사용자 행동 패턴 학습
2. **실시간 정보**: 날씨, 이벤트, 혼잡도 반영
3. **소셜 기능**: 다른 사용자의 계획 참고
4. **다국어 지원**: 외국인 관광객을 위한 계획 생성
5. **음성 인터페이스**: 음성으로 계획 생성 요청
